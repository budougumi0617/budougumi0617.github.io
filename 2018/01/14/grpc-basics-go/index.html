<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

  
    
    
      <link href="/css/fonts.css" rel="stylesheet" type="text/css">
    
  

  
  <title>[Go]gRPC Basics: GoからgRPCのストリーミングRPCを理解する</title>

  
  
  <link rel="stylesheet" href="/css/hugo-octopress.css">

  
  

  
    <link rel="stylesheet" href="/css/fork-awesome.min.css">
  

  
  <link href="https://budougumi0617.github.io/favicon.png" rel="icon">

  
  
  

  

  <meta name="description" content="">
  <meta name="keywords" content="Go,gRPC,Streaming RPC,Tutorial">

  <meta name="author" content="">

  
  <meta name="generator" content="Hugo 0.50" />

  
  

  
  
    

  
  
    <meta property="og:image" content="https://budougumi0617.github.io/logos/grpc.png"/>
  
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:image:src" content="https://budougumi0617.github.io/logos/grpc.png"/>
  
  
  <meta property="og:url" content="https://budougumi0617.github.io/2018/01/14/grpc-basics-go/"/>
  <meta property="og:type" content="article"/>
  <meta property="og:title" content="[Go]gRPC Basics: GoからgRPCのストリーミングRPCを理解する"/>
  <meta property="og:description" content="gRPC-goのクイックスタート、サーバーレリフレクションを試したので、次はgRPC Basics: Goをやってみた。クイックスタートを終えているので、そ"/>
  
  <meta name="twitter:title" content="[Go]gRPC Basics: GoからgRPCのストリーミングRPCを理解する"/>
  <meta name="twitter:description" content="gRPC-goのクイックスタート、サーバーレリフレクションを試したので、次はgRPC Basics: Goをやってみた。クイックスタートを終えているので、そ"/>
  <meta name="twitter:site" content="@budougumi0617"/>
  <meta name="twitter:domain" content="budougumi0617.github.io"/>
  <meta name="twitter:creator" content="@budougumi0617"/>



  

  
  <script type="text/javascript">
    (function(add, cla){window['UserHeatTag']=cla;window[cla]=window[cla]||function(){(window[cla].q=window[cla].q||[]).push(arguments)},window[cla].l=1*new Date();var ul=document.createElement('script');var tag = document.getElementsByTagName('script')[0];ul.async=1;ul.src=add;tag.parentNode.insertBefore(ul,tag);})('//uh.nakanohito.jp/uhj2/uh.js', '_uhtracker');_uhtracker({id:'uhUEw1Gd9C'});
  </script>
  
</head>
<body>


<header role="banner"><hgroup>
  
  <h1><a href="https://budougumi0617.github.io/">My External Storage</a></h1>
    <h2></h2>
</hgroup></header>


<nav role="navigation">
<fieldset class="mobile-nav">
  
  <select onchange="location = this.value;">
    <option value="">Navigate…</option>
      
        <option value="https://budougumi0617.github.io/">» Home</option>
      
        <option value="https://budougumi0617.github.io/2017/07/11/about-this-site/">» About</option>
      
        <option value="https://budougumi0617.github.io/post/">» Archives</option>
      

  </select>
</fieldset>


<ul class="main-navigation">
  
  
    
      <li><a href="https://budougumi0617.github.io/" title="Home">Home</a></li>
    
  
    
      <li><a href="https://budougumi0617.github.io/2017/07/11/about-this-site/" title="About"  target="_blank" >About</a></li>
    
  
    
      <li><a href="https://budougumi0617.github.io/post/" title="Archives"  target="_blank" >Archives</a></li>
    
  
</ul>


<ul class="subscription">
  
    
        <a href="https://budougumi0617.github.io/index.xml" target="_blank" type="application/rss+xml" title="RSS"><i class="fa fa-rss-square fa-lg"></i></a>
    
  

</ul>


</nav>


<div id="main">
  <div id="content">
    <div>
      <article class="hentry" role="article">

        
        

<header>
    <p class="meta">Jan 14, 2018
         - 7 minute read 
         - <a href="https://budougumi0617.github.io/2018/01/14/grpc-basics-go/#disqus_thread">Comments</a>

        
        
        
            - <a class="label" href="https://budougumi0617.github.io/categories/go/">Go </a><a class="label" href="https://budougumi0617.github.io/categories/grpc/">gRPC </a>
        
    </p>
    <h1 class="entry-title">
         [Go]gRPC Basics: GoからgRPCのストリーミングRPCを理解する 
    </h1>
</header>


        <div class="entry-content">
          
          
          
          
          

<p>gRPC-goのクイックスタート、サーバーレリフレクションを試したので、次はgRPC Basics: Goをやってみた。クイックスタートを終えているので、そちらで学習できている部分（環境構築手順、基本的な概念）には触れない。
クイックスタートでは出てこなかったStreaming RPCについてまとめた。</p>

<p><strong>gRPC Basics - Go</strong><br />
<a href="https://grpc.io/docs/tutorials/basic/go.html">https://grpc.io/docs/tutorials/basic/go.html</a></p>

<p>なお、上の公式ページの<a href="https://github.com/grpc/grpc.github.io/blob/master/docs/tutorials/basic/go.md">元MarkDown</a>とgrpc-goリポジトリ内の<a href="https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md">同等の内容のMarkDown</a>を比較すると、grpc-goの中の文書の方が新しいので、そちらを読んだ。
Basicsで使うサンプルコードは以下のリポジトリURLにある。</p>

<p><a href="https://github.com/grpc/grpc-go/tree/master/examples/route_guide">https://github.com/grpc/grpc-go/tree/master/examples/route_guide</a></p>

<h1 id="tl-dr">TL;DR</h1>

<ul>
<li>gRPCはクライアント/サーバーからの単方向ストリーム、双方向ストリームをサポートしている</li>
<li>protoファイルから自動生成された構造体の<code>Send</code>/<code>Recv</code>メソッドによってストリームを操作することができる</li>
<li>ストリームから<code>io.EOF</code>が取得されたら送信側からのストリームが終了したことを意味する</li>
<li>ストリーミングの方式によって、RPC終了時にストリーム操作用の構造体に定義されたメソッドを実行する場合もある</li>
</ul>

<p><strong>各ストリーミング形式ごとに定義されたRPC終了時に実行が必要なメソッド</strong></p>

<table>
<thead>
<tr>
<th>ストリーミング方式</th>
<th>Server側</th>
<th>Client側</th>
</tr>
</thead>

<tbody>
<tr>
<td>server-to-client</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<td>client-to-server</td>
<td><code>SendAndClose</code></td>
<td><code>CloseAndRecv</code></td>
</tr>

<tr>
<td>Bidirectional</td>
<td>-</td>
<td><code>CloseSend</code></td>
</tr>
</tbody>
</table>

<h1 id="streaming-rpc">Streaming RPC</h1>

<p>gRPCではクライアント/サーバ（あるいは両方）からデータをストリーミング処理で渡すメソッドの定義も行う事ができる。
protoファイルにある該当部分の定義は以下。</p>

<p><a href="https://github.com/grpc/grpc-go/blob/master/examples/route_guide/routeguide/route_guide.proto">https://github.com/grpc/grpc-go/blob/master/examples/route_guide/routeguide/route_guide.proto</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">  <span style="color:#586e75">// A server-to-client streaming RPC.
</span><span style="color:#586e75"></span>  <span style="color:#586e75">//
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// Obtains the Features available within the given Rectangle.  Results are
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// streamed rather than returned at once (e.g. in a response message with a
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// repeated field), as the rectangle may cover a large area and contain a
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// huge number of features.
</span><span style="color:#586e75"></span>  rpc ListFeatures(Rectangle) returns (stream Feature) {}

  <span style="color:#586e75">// A client-to-server streaming RPC.
</span><span style="color:#586e75"></span>  <span style="color:#586e75">//
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// Accepts a stream of Points on a route being traversed, returning a
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// RouteSummary when traversal is completed.
</span><span style="color:#586e75"></span>  rpc RecordRoute(stream Point) returns (RouteSummary) {}

  <span style="color:#586e75">// A Bidirectional streaming RPC.
</span><span style="color:#586e75"></span>  <span style="color:#586e75">//
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// Accepts a stream of RouteNotes sent while a route is being traversed,
</span><span style="color:#586e75"></span>  <span style="color:#586e75">// while receiving other RouteNotes (e.g. from other users).
</span><span style="color:#586e75"></span>  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}</code></pre></div>
<p>protoファイルの定義としてはストリームにしたいメソッドの引数型あるいは戻り値型の前に<code>stream</code>と予約語を追加するだけだ。</p>

<h1 id="grpc-basics-go">gRPC Basics: Go</h1>

<p>チュートリアルのサンプルコードのRouteGuideの定義からStreamng RPCの使い方を読み取る。</p>

<p><strong>gRPC Basics - Go</strong><br />
<a href="https://grpc.io/docs/tutorials/basic/go.html">https://grpc.io/docs/tutorials/basic/go.html</a></p>

<h1 id="a-server-side-streaming-rpc">A server-side streaming RPC</h1>

<p>サーバからクライアントに対してストリームでデータを渡すRPC。</p>

<h2 id="サーバサイドの定義">サーバサイドの定義</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L375">https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L375</a></p>

<p>Goの場合は以下のようなメソッドと構造体定義がprotoファイルから生成される。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#586e75">// プロトコルバッファーの定義は以下。
</span><span style="color:#586e75">// rpc ListFeatures(Rectangle) returns (stream Feature) {}
</span><span style="color:#586e75"></span>ListFeatures(<span style="color:#719e07">*</span>Rectangle, RouteGuide_ListFeaturesServer) <span style="color:#dc322f">error</span>

<span style="color:#586e75">// サーバからクライアントに対してFeature構造体をストリーミングする構造体のインターフェース定義
</span><span style="color:#586e75"></span><span style="color:#268bd2">type</span> RouteGuide_ListFeaturesServer <span style="color:#268bd2">interface</span> {
    Send(<span style="color:#719e07">*</span>Feature) <span style="color:#dc322f">error</span>
    grpc.ServerStream
}</code></pre></div>
<h2 id="サーバサイドでストリーミングを送信する実装">サーバサイドでストリーミングを送信する実装</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#server-side-streaming-rpc">https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#server-side-streaming-rpc</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#268bd2">func</span> (s <span style="color:#719e07">*</span>routeGuideServer) ListFeatures(rect <span style="color:#719e07">*</span>pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) <span style="color:#dc322f">error</span> {
    <span style="color:#719e07">for</span> _, feature <span style="color:#719e07">:=</span> <span style="color:#719e07">range</span> s.savedFeatures {
        <span style="color:#719e07">if</span> inRange(feature.Location, rect) {
            <span style="color:#719e07">if</span> err <span style="color:#719e07">:=</span> stream.Send(feature); err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
                <span style="color:#719e07">return</span> err
            }
        }
    }
    <span style="color:#719e07">return</span> <span style="color:#cb4b16">nil</span>
}</code></pre></div>
<p>ストリーミングは戻り値ではなく、メソッドの引数経由で行うようになる。<code>RouteGuide_ListFeaturesServer</code>は<code>Send(*Feature)</code>メソッドを持っているので、このメソッドを用いてデータをストリーミングする。
ストリーミングを終了する場合は<code>return nil</code>(何らかの異常で終了する場合は当然<code>return error</code>)を戻して終了する。</p>

<h2 id="クライアントサイドの定義">クライアントサイドの定義</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L232">https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L232</a></p>

<p>サーバーからストリームを受け取るクライアント側のメソッド定義は以下。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#586e75">// プロトコルバッファーの定義は以下。
</span><span style="color:#586e75">// rpc ListFeatures(Rectangle) returns (stream Feature) {}
</span><span style="color:#586e75"></span>ListFeatures(ctx context.Context, in <span style="color:#719e07">*</span>Rectangle, opts <span style="color:#719e07">...</span>grpc.CallOption) (RouteGuide_ListFeaturesClient, <span style="color:#dc322f">error</span>)

<span style="color:#586e75">// サーバーからストリーミングされるFeature構造体を受け取る構造体のインターフェース定義
</span><span style="color:#586e75"></span><span style="color:#268bd2">type</span> RouteGuide_ListFeaturesClient <span style="color:#268bd2">interface</span> {
    Recv() (<span style="color:#719e07">*</span>Feature, <span style="color:#dc322f">error</span>)
    grpc.ClientStream
}</code></pre></div>
<p>クライアント側のコードはプロトコルバッファーの定義と似たような形で生成される。戻り値のインターフェースにストリームを受け取る<code>Recv() (*Feature, error)</code>メソッドが定義されている。</p>

<h2 id="クライアントサイドでストリーミングを受け取る実装">クライアントサイドでストリーミングを受け取る実装</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#server-side-streaming-rpc-1">https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#server-side-streaming-rpc-1</a></p>

<p>サーバ側の<code>RouteGuide_ListFeaturesServer.Send</code>メソッドでストリーミングされたデータを、<code>RouteGuide_ListFeaturesClient.Recv</code>メソッドで受け取る。実際にメソッドを利用する際は次のような形になる。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">rect <span style="color:#719e07">:=</span> <span style="color:#719e07">&amp;</span>pb.Rectangle{ <span style="color:#719e07">...</span> }  <span style="color:#586e75">// initialize a pb.Rectangle
</span><span style="color:#586e75"></span>stream, err <span style="color:#719e07">:=</span> client.ListFeatures(context.Background(), rect)
<span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
    <span style="color:#719e07">...</span>
}
<span style="color:#719e07">for</span> {
    feature, err <span style="color:#719e07">:=</span> stream.Recv()
    <span style="color:#719e07">if</span> err <span style="color:#719e07">==</span> io.EOF { <span style="color:#586e75">// サーバ側でストリーミングが正常に終了(return nil)された
</span><span style="color:#586e75"></span>        <span style="color:#719e07">break</span>
    }
    <span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
        log.Fatalf(<span style="color:#2aa198">&#34;%v.ListFeatures(_) = _, %v&#34;</span>, client, err)
    }
    log.Println(feature)
}</code></pre></div>
<p>サーバ側でストリーミングが正常に終了(<code>return nil</code>)されたときは、<code>Recv</code>メソッドの戻り値として<code>io.EOF</code>を受け取ることになる。</p>

<h1 id="a-client-side-streaming-rpc">A client-side streaming RPC</h1>

<p>クライアントからサーバに対してストリームでデータを渡すRPC。</p>

<h2 id="サーバサイドの定義-1">サーバサイドの定義</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L380">https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L380</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#586e75">// プロトコルバッファーの定義は以下。
</span><span style="color:#586e75">// rpc RecordRoute(stream Point) returns (RouteSummary) {}
</span><span style="color:#586e75"></span>RecordRoute(RouteGuide_RecordRouteServer) <span style="color:#dc322f">error</span>

<span style="color:#586e75">// クライアントからPoint構造体をストリーミングで受け取る構造体のインターフェース定義
</span><span style="color:#586e75"></span><span style="color:#268bd2">type</span> RouteGuide_RecordRouteServer <span style="color:#268bd2">interface</span> {
    SendAndClose(<span style="color:#719e07">*</span>RouteSummary) <span style="color:#dc322f">error</span>
    Recv() (<span style="color:#719e07">*</span>Point, <span style="color:#dc322f">error</span>)
    grpc.ServerStream
}</code></pre></div>
<p>クライアントからのストリーミングが終了したときは<code>RouteGuide_RecordRouteServer.SendAndClose</code>を呼ぶ必要がある。</p>

<h2 id="サーバサイドでストリーミングを受け取る実装">サーバサイドでストリーミングを受け取る実装</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#client-side-streaming-rpc">https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#client-side-streaming-rpc</a></p>

<p>サーバ側の実装の概要は以下。クライアントからのストリーミングが終了した時、<code>RouteGuide_RecordRouteServer.Recv</code>メソッドの戻り値が<code>io.EOF</code>となるので、<code>RouteGuide_RecordRouteServer.SendAndClose</code>メソッドを実行してメソッドを終了する。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#719e07">for</span> {
    point, err <span style="color:#719e07">:=</span> stream.Recv() <span style="color:#586e75">// streamはメソッド引数のRouteGuide_RecordRouteServer
</span><span style="color:#586e75"></span>    <span style="color:#719e07">if</span> err <span style="color:#719e07">==</span> io.EOF {
        endTime <span style="color:#719e07">:=</span> time.Now()
        <span style="color:#719e07">return</span> stream.SendAndClose(<span style="color:#719e07">&amp;</span>pb.RouteSummary{
          <span style="color:#586e75">// Initialize
</span><span style="color:#586e75"></span>        })
    }
    <span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
        <span style="color:#719e07">return</span> err
    }
    <span style="color:#586e75">// Do something...
</span><span style="color:#586e75"></span>}</code></pre></div>
<h2 id="クライアントサイドの定義-1">クライアントサイドの定義</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L237">https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L237</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#586e75">// プロトコルバッファーの定義は以下。
</span><span style="color:#586e75">// rpc RecordRoute(stream Point) returns (RouteSummary) {}
</span><span style="color:#586e75"></span>RecordRoute(ctx context.Context, opts <span style="color:#719e07">...</span>grpc.CallOption) (RouteGuide_RecordRouteClient, <span style="color:#dc322f">error</span>)

<span style="color:#586e75">// クライアントからサーバに対してPoint構造体をストリーミングする構造体のインターフェース定義
</span><span style="color:#586e75"></span><span style="color:#268bd2">type</span> RouteGuide_RecordRouteClient <span style="color:#268bd2">interface</span> {
    Send(<span style="color:#719e07">*</span>Point) <span style="color:#dc322f">error</span>
    CloseAndRecv() (<span style="color:#719e07">*</span>RouteSummary, <span style="color:#dc322f">error</span>)
    grpc.ClientStream
}</code></pre></div>
<p>server-side streaming RPCのときは<code>return nil</code>でストリームを終了していたが、client-sideの場合は<code>RouteGuide_RecordRouteClient.CloseAndRecv</code>メソッドでストリームを終了する。</p>

<h2 id="クライアントでストリーミングを送信する実装">クライアントでストリーミングを送信する実装</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#client-side-streaming-rpc-1">https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#client-side-streaming-rpc-1</a></p>

<p>エラー処理などをほぼ省略した実装は以下の通り。明示的に<code>CloseAndRecv</code>メソッドを呼ぶ。</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">stream, err <span style="color:#719e07">:=</span> client.RecordRoute(context.Background())
<span style="color:#719e07">for</span> _, point <span style="color:#719e07">:=</span> <span style="color:#719e07">range</span> points { <span style="color:#586e75">// pointsはストリーミングするPoint群
</span><span style="color:#586e75"></span>    <span style="color:#719e07">if</span> err <span style="color:#719e07">:=</span> stream.Send(point); err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
        log.Fatalf(<span style="color:#2aa198">&#34;%v.Send(%v) = %v&#34;</span>, stream, point, err)
    }
}
reply, err <span style="color:#719e07">:=</span> stream.CloseAndRecv()</code></pre></div>
<h1 id="a-bidirectional-streaming-rpc">A bidirectional streaming RPC</h1>

<p>サーバ/クライアント双方でストリーミングを行いながらやりとりするRPC</p>

<h2 id="サーバサイドの定義-2">サーバサイドの定義</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L385">https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L385</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#586e75">// プロトコルバッファーの定義は以下。
</span><span style="color:#586e75">// rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
</span><span style="color:#586e75"></span>RouteChat(RouteGuide_RouteChatServer) <span style="color:#dc322f">error</span>

<span style="color:#586e75">// 双方向ストリーミングを行う構造体のインターフェース定義
</span><span style="color:#586e75"></span><span style="color:#268bd2">type</span> RouteGuide_RouteChatServer <span style="color:#268bd2">interface</span> {
    Send(<span style="color:#719e07">*</span>RouteNote) <span style="color:#dc322f">error</span>
    Recv() (<span style="color:#719e07">*</span>RouteNote, <span style="color:#dc322f">error</span>)
    grpc.ServerStream
}</code></pre></div>
<p>ひとつの構造体で送信用、受信用のストリームの送受信が行える。</p>

<h2 id="双方向ストリーミングを行うサーバ側の実装">双方向ストリーミングを行うサーバ側の実装</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#bidirectional-streaming-rpc">https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#bidirectional-streaming-rpc</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#719e07">for</span> {
    in, err <span style="color:#719e07">:=</span> stream.Recv() <span style="color:#586e75">// streamはメソッドの引数のRouteNote
</span><span style="color:#586e75"></span>      <span style="color:#719e07">if</span> err <span style="color:#719e07">==</span> io.EOF {
          <span style="color:#719e07">return</span> <span style="color:#cb4b16">nil</span>
      }
      <span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
          <span style="color:#719e07">return</span> err
      }
      key <span style="color:#719e07">:=</span> serialize(in.Location)
                  <span style="color:#719e07">...</span> <span style="color:#586e75">// look for notes to be sent to client
</span><span style="color:#586e75"></span>      <span style="color:#719e07">for</span> _, note <span style="color:#719e07">:=</span> <span style="color:#719e07">range</span> s.routeNotes[key] {
          <span style="color:#719e07">if</span> err <span style="color:#719e07">:=</span> stream.Send(note); err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
              <span style="color:#719e07">return</span> err
          }
      }
}</code></pre></div>
<p><code>Recv</code>メソッドと<code>Send</code>メソッドでストリームの送受信を行う点は変わらない。また、<code>io.EOF</code>をクライアントから受け取ったあとに<code>SendAndClose</code>メソッドの類を実行する必要もない。</p>

<h2 id="クライアントサイドの定義-2">クライアントサイドの定義</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L242">https://github.com/grpc/grpc-go/blob/1cd234627e6f392ade0527d593eb3fe53e832d4a/examples/route_guide/routeguide/route_guide.pb.go#L242</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#586e75">// プロトコルバッファーの定義は以下。
</span><span style="color:#586e75">// rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
</span><span style="color:#586e75"></span>RouteChat(ctx context.Context, opts <span style="color:#719e07">...</span>grpc.CallOption) (RouteGuide_RouteChatClient, <span style="color:#dc322f">error</span>)

<span style="color:#586e75">// 双方向ストリーミングを行う構造体のインターフェース定義
</span><span style="color:#586e75"></span><span style="color:#268bd2">type</span> RouteGuide_RouteChatClient <span style="color:#268bd2">interface</span> {
    Send(<span style="color:#719e07">*</span>RouteNote) <span style="color:#dc322f">error</span>
    Recv() (<span style="color:#719e07">*</span>RouteNote, <span style="color:#dc322f">error</span>)
    grpc.ClientStream
}</code></pre></div>
<p>サーバー側同様、送信用、受信用のストリームの操作がひとつのインターフェースにまとめられている。</p>

<h2 id="双方向ストリーミングを行うクライアント側の実装">双方向ストリーミングを行うクライアント側の実装</h2>

<p><a href="https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#bidirectional-streaming-rpc-1">https://github.com/grpc/grpc-go/blob/master/examples/gotutorial.md#bidirectional-streaming-rpc-1</a></p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">stream, err <span style="color:#719e07">:=</span> client.RouteChat(context.Background())
waitc <span style="color:#719e07">:=</span> <span style="color:#b58900">make</span>(<span style="color:#268bd2">chan</span> <span style="color:#268bd2">struct</span>{})
<span style="color:#719e07">go</span> <span style="color:#268bd2">func</span>() {
    <span style="color:#719e07">for</span> {
        in, err <span style="color:#719e07">:=</span> stream.Recv()
        <span style="color:#719e07">if</span> err <span style="color:#719e07">==</span> io.EOF {
          <span style="color:#586e75">// read done.
</span><span style="color:#586e75"></span>          <span style="color:#b58900">close</span>(waitc)
          <span style="color:#719e07">return</span>
        }
        <span style="color:#719e07">if</span> err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
            log.Fatalf(<span style="color:#2aa198">&#34;Failed to receive a note : %v&#34;</span>, err)
        }
        log.Printf(<span style="color:#2aa198">&#34;Got message %s at point(%d, %d)&#34;</span>, in.Message, in.Location.Latitude, in.Location.Longitude)
    }
}()
<span style="color:#719e07">for</span> _, note <span style="color:#719e07">:=</span> <span style="color:#719e07">range</span> notes {
    <span style="color:#719e07">if</span> err <span style="color:#719e07">:=</span> stream.Send(note); err <span style="color:#719e07">!=</span> <span style="color:#cb4b16">nil</span> {
        log.Fatalf(<span style="color:#2aa198">&#34;Failed to send a note: %v&#34;</span>, err)
    }
}
stream.CloseSend()
<span style="color:#719e07">&lt;-</span>waitc</code></pre></div>
<p>基本的な使い方は今まで同様。最後に<code>CloseSend</code>メソッドを実行して終わるのがお作法らしい。</p>

<h1 id="チュートリアルを終えて">チュートリアルを終えて</h1>

<p>protoファイルのひとつの定義からサーバー用、クライアント用のインターフェースや実装が複数自動生成されるため、コードだけ見ても使い方がよくわからなかったのだが、今回のBasicsでだいぶわかった気がする。ただ、このチュートリアルもRPCの引数が単一のstreamだけのサンプルだったりするので、複数引数で定義すると操作方法が変わるかもしれない（あるいは定義できない？）</p>

<h1 id="grpc関連の記事">gRPC関連の記事</h1>

<ul>
<li><a href="/2018/01/01/hello-grpc-go/">[Go]gRPCのGo Quick Startをやってみた。</a></li>
<li><a href="/2018/01/04/server-reflection-tutorial/">[Go][gRPC]Server Reflection Tutorialをやってみた</a></li>
<li><a href="/2018/01/21/try-gomock-on-grpc-go/">[Go]gomockを使ったgRPCのテスト</a></li>
<li><a href="/2018/02/03/grpc-gateway-for-rest-api">[Go]gRPC GatewayでgRPCに対するREST APIを自動生成する</a></li>
</ul>

        </div>
        

<footer>
  <p class="meta">
    <span class="byline author vcard">Posted by <span class="fn"></span></span>
    
    <time>Jan 14, 2018</time>
    
      <span class="categories">
        Tags:
        
          <a class="category" href="https://budougumi0617.github.io/tags/golang">golang</a>  <a class="category" href="https://budougumi0617.github.io/tags/grpc">grpc</a>  
    
    </span>
  </p>

  
  

  

  <p class="meta">
    
        <a class="basic-alignment left" href="https://budougumi0617.github.io/2018/01/10/review-sleep-revolution/" title="[書評]スリープレボリューションを読んだ">[書評]スリープレボリューションを読んだ</a>
    

    
      <a class="basic-alignment right" href="https://budougumi0617.github.io/2018/01/16/review-the-best-way-to-rest/" title="[書評]世界のエリートがやっている 最高の休息法を読んだ">[書評]世界のエリートがやっている 最高の休息法を読んだ</a>
    
  </p>
  
    
      <div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'http-budougumi0617-github-io';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
  
</footer>

      </article>
    </div>
    

<aside class="sidebar thirds">
  <section class="first odd">

    
      <h1>This blog</h1>
    

    <p>
      
        budougumi0617 の技術ブログです。
    </br>
    主にGoについて書いています。
    </br>
      
    </p>
  </section>



  
  <ul class="sidebar-nav">
    <li class="sidebar-nav-item">
      <a target="_blank" href="https://github.com/budougumi0617" title="https://github.com/budougumi0617"><i class="fa fa-github fa-3x"></i></a>
      
      
      <a target="_blank" href="https://twitter.com/budougumi0617" title="https://twitter.com/budougumi0617"><i class="fa fa-twitter fa-3x"></i></a>
      
         
      
      <a target="_blank" href="https://www.linkedin.com/in/budougumi0617/" title="https://www.linkedin.com/in/budougumi0617/"><i class="fa fa-linkedin fa-3x"></i></a>
      
      
      
      
      
      

    
    
    </li>
  </ul>

  

  
    
      <section class="odd">
        
          <h1>Reccomend Categories</h1>
        
        
          <li>
            <a href="https://budougumi0617.github.io/categories/go/" title="Go" >Go</a>
          </li>
        
          <li>
            <a href="https://budougumi0617.github.io/categories/spinnaker/" title="Spinnaker" >Spinnaker</a>
          </li>
        
          <li>
            <a href="https://budougumi0617.github.io/categories/presentation/" title="発表資料" >発表資料</a>
          </li>
        
          <li>
            <a href="https://budougumi0617.github.io/categories/report/" title="イベントレポート" >イベントレポート</a>
          </li>
        
          <li>
            <a href="https://budougumi0617.github.io/categories/" title="その他のカテゴリー一覧" >その他のカテゴリー一覧</a>
          </li>
        
      </section>
    
  

  
  
  
    
      <section class="even">
        <h1>Recent Posts</h1>
        <ul id="recent_posts">
          
          
            
              <li class="post">
                <a href="/2019/01/06/redirect-by-http-on-hugo/">HTTPSで公開しているHugoで一部のページがHTTPでページ遷移してしまう #hugo</a>
              </li>
            
          
            
              <li class="post">
                <a href="/2019/01/05/set-ogp-in-hugo-blog/">HugoでOGP(Facebook用のアイキャッチ画像)を設定する #hugo</a>
              </li>
            
          
            
              <li class="post">
                <a href="/2019/01/04/set-twitter-image-in-hugo-blog/">Hugoのブログ記事にTwitter Card(アイキャッチ画像)を設定する #hugo</a>
              </li>
            
          
            
              <li class="post">
                <a href="/2018/12/27/retrospective-2018/">2018年振り返り</a>
              </li>
            
          
            
              <li class="post">
                <a href="/2018/12/19/report-golangtokyo-20/">golang.tokyo #20 忘年LT大会！！ 参加メモ #golangtokyo</a>
              </li>
            
          
        </ul>
      </section>
    
  
</aside>

  </div>
</div>

<footer role="contentinfo">
  <p>Copyright &copy; 2019  - <a href="https://budougumi0617.github.io/license/">License</a> -
  <span class="credit">Powered by <a target="_blank" href="https://gohugo.io">Hugo</a> and <a target="_blank" href="https://github.com/parsiya/hugo-octopress/">Hugo-Octopress</a> theme.
</p>

</footer>






<script>
  var _gaq=[['_setAccount','UA-43042615-4'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

</body>
</html>

